<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>LENA — Futuristic Nebula</title>
  <style>
    :root{
      --accent: #61a8ff;
      --accent-2: #bfe2ff;
      --bg: #05060a;
    }
    html,body{
      height:100%;
      margin:0;
      background:var(--bg);
      font-family: Inter, "Segoe UI", Roboto, system-ui, -apple-system, "Helvetica Neue", Arial;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      overflow:hidden;
    }

    /* full canvas background */
    canvas#bg {
      position:fixed;
      inset:0;
      width:100%;
      height:100%;
      display:block;
      z-index:0;
    }

    /* container for UI elements */
    .ui {
      position:relative;
      z-index:10;
      width:100%;
      height:100%;
      display:flex;
      align-items:center;
      justify-content:center;
      pointer-events:none; /* allow clicks to fall through except inputs */
    }

    .center {
      pointer-events:auto;
      width:100%;
      max-width:1200px;
      padding:40px;
      box-sizing:border-box;
      display:flex;
      align-items:center;
      justify-content:center;
      flex-direction:column;
      gap:28px;
    }

    /* LENA headline */
    .hero {
      text-align:center;
      transform:translateY(-24px);
      user-select:none;
    }

    .hero h1 {
      margin:0;
      font-weight:800;
      letter-spacing:6px;
      font-size:clamp(48px, 8vw, 128px);
      color:rgba(255,255,255,0.95);
      position:relative;
      z-index:2;
      mix-blend-mode:screen;
      text-shadow:
        0 6px 40px rgba(20,60,120,0.55),
        0 1px 12px rgba(97,168,255,0.35),
        0 0 90px rgba(97,168,255,0.2);
      -webkit-text-stroke: 0.6px rgba(255,255,255,0.04);
      filter:drop-shadow(0 8px 60px rgba(30,70,150,0.25));
    }

    .subtle {
      margin-top:6px;
      color: rgba(190,220,255,0.85);
      font-size:16px;
      letter-spacing:1px;
    }

    /* stylized input bar */
    .input-shell {
      width:clamp(560px, 60vw, 900px);
      max-width:95%;
      margin-top:10px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      pointer-events:auto;
    }

    .chat-input {
      display:flex;
      align-items:center;
      gap:12px;
      background: rgba(9,11,16,0.6);
      border-radius:28px;
      padding:18px 20px;
      border:1px solid rgba(255,255,255,0.06);
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.02), 0 6px 40px rgba(8,10,14,0.6);
      width:100%;
      backdrop-filter: blur(6px) saturate(120%);
      transition: transform .22s ease, box-shadow .22s ease;
    }

    .chat-input:focus-within{
      transform:translateY(-4px);
      box-shadow: 0 18px 80px rgba(30,80,160,0.18);
    }

    .chat-input input {
      background: transparent;
      border: none;
      outline: none;
      color: rgba(240,248,255,0.95);
      font-size:16px;
      width:100%;
      padding:6px 0;
      -webkit-appearance:none;
    }

    .placeholder {
      color: rgba(200,220,255,0.38);
    }

    .send-btn {
      width:48px;
      height:48px;
      border-radius:50%;
      border:1px solid rgba(255,255,255,0.06);
      display:flex;
      align-items:center;
      justify-content:center;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      box-shadow: 0 6px 18px rgba(5,8,12,0.5);
      cursor:pointer;
      transition: transform .12s ease;
    }

    .send-btn:active{ transform:scale(.96) }

    /* Arc around send button */
    .send-icon {
      width:18px;
      height:18px;
      display:inline-block;
      transform:rotate(-45deg);
      color:var(--accent-2);
      filter: drop-shadow(0 6px 18px rgba(30,90,200,0.18));
    }

    /* small footer text */
    .footer-text {
      color: rgba(200,220,255,0.6);
      margin-top:6px;
      font-size:13px;
      letter-spacing:1px;
    }

    /* cursor glow overlay for aesthetic */
    .glow {
      position:absolute;
      z-index:5;
      pointer-events:none;
      inset:0;
      mix-blend-mode:screen;
      opacity:0.75;
    }

    @media (max-width:640px){
      .hero h1{ letter-spacing:3px; }
      .subtle{ font-size:13px; }
      .input-shell{ padding:0 14px; }
    }
  </style>
</head>
<body>
  <!-- WebGL background canvas -->
  <canvas id="bg"></canvas>

  <!-- UI overlay -->
  <div class="ui">
    <div class="center" aria-hidden="false">
      <div class="hero" role="banner">
        <h1 id="brand">LENA</h1>
        <div class="subtle">What would you like to ask LENA?</div>
      </div>

      <div class="input-shell" role="region" aria-label="LENA chat input">
        <div class="chat-input" id="chatInput">
          <input id="userText" type="text" placeholder="What do you want to know?" aria-label="Message to LENA" />
          <button class="send-btn" id="sendBtn" aria-label="Send message">
            <svg class="send-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" >
              <path d="M22 2L11 13" />
              <path d="M22 2l-7 20-4-9-9-4 20-7z" />
            </svg>
          </button>
        </div>
      </div>

      <div class="footer-text">LENA — powered by webgl nebula</div>
    </div>
  </div>

  <!-- subtle overlay vignette / glow -->
  <svg class="glow" preserveAspectRatio="none" viewBox="0 0 100 100">
    <defs>
      <radialGradient id="g1" cx="50%" cy="40%" r="60%">
        <stop offset="0%" stop-color="#7fbfff" stop-opacity="0.28" />
        <stop offset="40%" stop-color="#4a7cff" stop-opacity="0.12" />
        <stop offset="100%" stop-color="#000010" stop-opacity="0.06" />
      </radialGradient>
    </defs>
    <rect x="0" y="0" width="100" height="100" fill="url(#g1)"></rect>
  </svg>

  <script>
  // -----------------------
  // Minimal WebGL fragment shader nebula (GPU)
  // Uses a fullscreen quad; no external libs.
  // -----------------------

  const canvas = document.getElementById('bg');
  const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');

  if (!gl) {
    document.body.innerHTML = '<p style="color:white;padding:20px;">WebGL not supported in this browser.</p>';
    throw new Error('WebGL not supported');
  }

  // Resize handling
  function resize() {
    const dpr = Math.min(window.devicePixelRatio || 1, 2);
    const w = Math.floor(innerWidth * dpr);
    const h = Math.floor(innerHeight * dpr);
    if (canvas.width !== w || canvas.height !== h) {
      canvas.width = w;
      canvas.height = h;
      canvas.style.width = innerWidth + 'px';
      canvas.style.height = innerHeight + 'px';
      gl.viewport(0, 0, w, h);
    }
  }
  window.addEventListener('resize', resize);
  resize();

  // vertex shader (simple full-screen triangle)
  const vert = `#version 300 es
  precision highp float;
  in vec2 position;
  out vec2 vUv;
  void main(){
    vUv = position * 0.5 + 0.5;
    gl_Position = vec4(position, 0.0, 1.0);
  }`;

  // fragment shader - fbm noise + swirling nebula coloring
  const frag = `#version 300 es
  precision highp float;
  out vec4 fragColor;
  in vec2 vUv;
  uniform float u_time;
  uniform vec2 u_resolution;
  uniform vec2 u_mouse;

  // ---- random / noise utilities by iq ----
  float hash(vec2 p) {
    vec3 p3 = fract(vec3(p.xyx) * 0.1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.x + p3.y) * p3.z);
  }

  float noise(in vec2 x) {
    vec2 i = floor(x);
    vec2 f = fract(x);
    vec2 u = f*f*(3.0-2.0*f);
    return mix(mix(hash(i + vec2(0.0,0.0)), hash(i + vec2(1.0,0.0)), u.x),
               mix(hash(i + vec2(0.0,1.0)), hash(i + vec2(1.0,1.0)), u.x), u.y);
  }

  // fbm - layered noise
  float fbm(vec2 p) {
    float value = 0.0;
    float amp = 0.5;
    float freq = 1.0;
    for(int i=0;i<6;i++){
      value += amp * noise(p * freq);
      freq *= 2.0;
      amp *= 0.5;
      p = mat2(1.6, -1.2, 1.2, 1.6) * p; // rotate sample
    }
    return value;
  }

  void main(){
    vec2 uv = (vUv - 0.5) * vec2(u_resolution.x/u_resolution.y, 1.0);

    // Animate coordinates with time and mouse
    vec2 m = (u_mouse.xy / u_resolution) - 0.5;
    vec2 p = uv * 1.3 + vec2(u_time*0.03, u_time*0.02) + m * 1.8;

    // swirl vector field
    float n = fbm(p * 1.2);
    float n2 = fbm(p * 2.5 - n * 0.7 + vec2(u_time*0.05));
    float intensity = pow(abs(n2), 1.6);

    // layered glow center
    float dist = length(uv - m*0.25);
    float center = smoothstep(0.9, 0.2, dist) * 1.35;

    // color mapping - cold blue to white
    vec3 colBase = mix(vec3(0.02,0.04,0.08), vec3(0.18,0.28,0.56), n);
    vec3 highlight = vec3(0.85,0.94,1.0);
    vec3 col = mix(colBase, highlight, pow(intensity + 0.18, 2.0) * 0.9);

    // add a band / beam of light (like grok)
    float beam = smoothstep(0.8, 0.0, abs(uv.x - m.x*0.8));
    col += vec3(0.55,0.7,1.0) * beam * 0.45;

    // final composition
    float fog = smoothstep(0.0, 0.8, intensity * center);
    vec3 finalColor = col * (0.8 * fog + 0.35 * center);

    // subtle vignetting
    float vign = smoothstep(1.05, 0.35, length(uv) * 1.2);
    finalColor *= mix(0.6, 1.0, vign);

    // add grain
    float g = (noise(uv * 300.0 + u_time * 0.1) - 0.5) * 0.02;
    finalColor += g;

    fragColor = vec4(finalColor, 1.0);
  }`;

  // create shader program
  function createShader(type, source){
    const s = gl.createShader(type);
    gl.shaderSource(s, source);
    gl.compileShader(s);
    if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){
      console.error(gl.getShaderInfoLog(s));
      throw new Error('Shader compile failed');
    }
    return s;
  }

  const vs = createShader(gl.VERTEX_SHADER, vert);
  const fs = createShader(gl.FRAGMENT_SHADER, frag);
  const program = gl.createProgram();
  gl.attachShader(program, vs);
  gl.attachShader(program, fs);

  // bind attribute location and link
  gl.bindAttribLocation(program, 0, 'position');
  gl.linkProgram(program);
  if(!gl.getProgramParameter(program, gl.LINK_STATUS)){
    console.error(gl.getProgramInfoLog(program));
    throw new Error('Program link failed');
  }
  gl.useProgram(program);

  // full-screen triangle vertices
  const vertices = new Float32Array([
    -1, -1,
     3, -1,
    -1,  3
  ]);
  const vao = gl.createVertexArray();
  gl.bindVertexArray(vao);
  const vbo = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

  gl.enableVertexAttribArray(0);
  gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

  // uniforms
  const u_time = gl.getUniformLocation(program, 'u_time');
  const u_resolution = gl.getUniformLocation(program, 'u_resolution');
  const u_mouse = gl.getUniformLocation(program, 'u_mouse');

  let start = performance.now();
  let mouse = [canvas.width/2, canvas.height/2];

  // track mouse for parallax
  window.addEventListener('mousemove', (e) => {
    const r = canvas.getBoundingClientRect();
    mouse[0] = (e.clientX - r.left) * (canvas.width / r.width);
    mouse[1] = (e.clientY - r.top) * (canvas.height / r.height);
  });

  // touch support
  window.addEventListener('touchmove', (e) => {
    const t = e.touches[0];
    const r = canvas.getBoundingClientRect();
    mouse[0] = (t.clientX - r.left) * (canvas.width / r.width);
    mouse[1] = (t.clientY - r.top) * (canvas.height / r.height);
  }, {passive:true});

  // animation loop
  function render(){
    resize();
    const now = performance.now();
    const t = (now - start) * 0.001;

    gl.useProgram(program);
    gl.uniform1f(u_time, t);
    gl.uniform2f(u_resolution, canvas.width, canvas.height);
    gl.uniform2f(u_mouse, mouse[0], canvas.height - mouse[1]); // invert Y for shader

    gl.bindVertexArray(vao);
    gl.drawArrays(gl.TRIANGLES, 0, 3);

    requestAnimationFrame(render);
  }
  requestAnimationFrame(render);

  // -- small interactive niceties for the UI --
  const input = document.getElementById('userText');
  const sendBtn = document.getElementById('sendBtn');

  sendBtn.addEventListener('click', () => {
    pulseSend();
    const v = input.value.trim();
    if (v) {
      showToast(`You asked: ${v}`);
      input.value = '';
      // Integrate here with your Botpress endpoint if desired.
    }
  });

  input.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      sendBtn.click();
    }
  });

  // subtle send button pulse
  function pulseSend(){
    sendBtn.animate([{ transform: 'scale(1)' }, { transform: 'scale(0.96)' }, { transform: 'scale(1)' }], { duration:160, easing:'ease-out' });
  }

  // temporary toast message that mimics chat feedback
  function showToast(msg){
    const t = document.createElement('div');
    t.textContent = msg;
    Object.assign(t.style, {
      position:'fixed',
      left:'50%',
      transform:'translateX(-50%)',
      bottom:'48px',
      background:'rgba(15,20,30,0.7)',
      color:'#dfefff',
      padding:'10px 18px',
      borderRadius:'12px',
      fontSize:'13px',
      zIndex:99999,
      boxShadow:'0 8px 40px rgba(20,60,120,0.25)'
    });
    document.body.appendChild(t);
    t.animate([{opacity:0, transform:'translateY(8px)'},{opacity:1, transform:'translateY(0)'}],{duration:260,fill:'forwards'});
    setTimeout(()=> {
      t.animate([{opacity:1},{opacity:0, transform:'translateY(8px)'}],{duration:240}).onfinish = () => t.remove();
    }, 1400);
  }

  // small accessibility: focus input on click anywhere in input shell
  document.getElementById('chatInput').addEventListener('click', () => input.focus());

  </script>
</body>
</html>

